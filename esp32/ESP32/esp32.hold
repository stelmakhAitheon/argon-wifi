

    // static void addFunc(std::string name) {
    //     mutex.lock();
    //     funcCount++;
    //     functions.push_back(name);
    //     mutex.unlock();   
    // }
    // static void addReceive(std::string name, bool show = true) {
    //     if(!show)
    //         return;
    //     mutex.lock();
    //     received = received + name + "\r\n";
    //     mutex.unlock(); 
    // }
    // static void updateMessage() {
    //     // functions.push_back(std::string("test"));
    //     message = "funcount = " + std::to_string(funcCount) + "\r\n";
    //     // functions.clear();
    //     // message = "";
    //     for(size_t i = 0; i < functions.size(); i++)
    //         message = message + "func = " + functions[i];
    // }

    // void cmux() {
    //     _parser.send("AT+CMUX=0");
    //     // bool success = 
    //     _parser.recv("OK");
    // }

    // void testCMUX(uint8_t *cmd, int len) {
    //     static bool first = true;

    //     if(!first)
    //         return;
    //     first = false;
    //     // cmux();
    //     addFunc("FIRST TEST CMUX\r\n");
    //     cmux();
    //     readCMUX();
        
    //     // uint8_t atcmdConf[] = {0xd, 0xa, '\r', '\n'}; 
    //     //open 0 channel
    //     sendChannel(0, 63, true, nullptr, 0);
    //     readCMUX();
    //     //open 1 channel
    //     sendChannel(1, 63, true, nullptr, 0);
    //     readCMUX();

    //     // // send bytes to ch 0 //e1 5 7 d
    //     // uint8_t bytes[] = {0xe1, 0x5, 0x7, 0xd, '\r', '\n'};
    //     // sendChannel(0, 239, false, bytes, sizeof(bytes));
    //     // readCMUX();

    //     uint8_t at[] = "AT\r\n";
    //     sendChannel(1, 239, false, at, sizeof(at));
    //     // ThisThread::sleep_for(500);
    //     // sendChannel(1, 239, false, atcmdConf, sizeof(atcmdConf));
    //     readCMUX();

    //     // uint8_t atmac[] = "AT+GETMAC=0\r\n"; 
    //     // sendChannel(1, 239, false, atmac, sizeof(atmac));
    //     // readCMUX(true);

    //     uint8_t atdhcp[] = "AT+CWDHCP=0,3\r\n"; 
    //     sendChannel(1, 239, false, atdhcp, sizeof(atdhcp));
    //     readCMUX();

    //     uint8_t atwifi[] = "AT+CWJAP=\"Aitheon\",\"Ukraine123\"\r\n"; 
    //     sendChannel(1, 239, false, atwifi, sizeof(atwifi));
    //     readCMUX(true);
    //     readCMUX(true);
    //     readCMUX(true);
    //     readCMUX(true);
    //     readCMUX(true);

    //     uint8_t atip[] = "AT+CIFSR\r\n"; 
    //     sendChannel(1, 239, false, atip, sizeof(atip));
    //     readCMUX(true);


    //     //send bytes to ch 0 //e1 5 7 d
    //     // uint8_t bytes[] = {0xe1, 0x5, 0x7, 0xd};
    //     // sendChannel(0, 239, false, bytes, sizeof(bytes));
    //     // readCMUX();

    //     // uint8_t atcmd[] = "AT+GETMAC=0\r\n"; 
    //     // uint8_t atcmd[] = "AT+CIFSR\r\n"; 
        
    //     // sendChannel(1, 239, false, atcmdConf, sizeof(atcmdConf));

    //     // uint8_t atcmd[] = "AT+CWDHCP=1,1\r\n"; 
    //     // sendChannel(1, 239, false, atcmd, sizeof(atcmd));
        
    //     // readCMUX(true);
    //     // sendChannel(1, 239, false, atcmdConf, sizeof(atcmdConf));
    //     // readCMUX(true);

        
        
        
    //     // // ThisThread::sleep_for(5000);
    //     // readCMUX(true);
    //     // readCMUX(true);
    //     // readCMUX(true);
    //     // readCMUX(true);


    //     // readCMUX(true);

    //     // addReceive("AFTER WIFI");
    //     // uint8_t atip[] = "AT+CIFSR\r\n"; 
    //     // sendChannel(1, 239, false, atip, sizeof(atip));
    //     // readCMUX(true);
    //     // readCMUX(true);

    //     // readCMUX(true);
    //     // readCMUX(true);
    //     // readCMUX(true);
    //     // readCMUX(true);

    //     // uint8_t atmac[] = "AT+GETMAC=0\r\n"; 
    //     // sendChannel(1, 239, false, atmac, sizeof(atmac));
    //     // readCMUX(true);




    //     // ThisThread::sleep_for(500);
    //     // uint8_t atcmdConf[] = {0xd, 0xa}; 
    //     // ThisThread::sleep_for(1000);
    //     // sendChannel(1, 239, false, atcmdConf, sizeof(atcmdConf));
    //     // ThisThread::sleep_for(2000);

    //     // readCMUX(true);
    //     // readCMUX(true);
    //     addFunc("AFTER CMUX\r\n");
    // }
    
    // void startCMUXMode() {
    //     static bool first = true;
    //     if(!first)
    //         return;
    //     first = false;
    //     cmux();
    //     readCMUX();
    // }

    // void openChannels() {
    //     static bool first = true;
    //     if(!first)
    //         return;
    //     first = false;
    //     startCMUXMode();
    //     sendChannel(0, 63, true, nullptr, 0);
    //     readCMUX();
    //     sendChannel(1, 63, true, nullptr, 0);
    //     readCMUX();
    //     sendChannel(2, 63, true, nullptr, 0);
    //     readCMUX();
    //     addReceive("YEAH!!!");
    // }
    
    // bool readCMUX(bool show=false, bool showParse = false) {
    //     // int waitI = 0;
    //     while(!_serial.readable()) {
    //         // if(waitI++ >= 100)
    //         //     return false;
    //         ThisThread::sleep_for(10);
    //     }

    //     std::string tmp = "";
    //     while(_serial.readable()) {
    //         char symbol[2] = {0};
    //         _serial.read(symbol, 1);
    //         tmp.push_back(symbol[0]);
    //         // ThisThread::sleep_for(100);
    //     }

    //     int bufSize = tmp.size();

    //     int posCmdStart, posCmdEnd;
    //     int posStart = 0;

    //     // addReceive("next CMUX", show);
    //     // char buf[] = {0xf9, 0x1, 0xef, 0x9, 0xe3, 0x5, 0x7, 0xd, 0x9a, 0xf9, 0xf9, 0x1, 0xef, 0x9, 0xe3, 0x5, 0x7, 0xd, 0x9a, 0xf9};
    //     // tmp = buf;
    //     while(true) {
    //         // addReceive("find posCmdStart = " + std::to_string(posStart));
    //         posCmdStart = tmp.find(gsm0710::proto::BASIC_FLAG, posStart);
    //         if(posCmdStart == -1) {
    //             // addReceive("NOT FOUND START ");
    //             break;
    //         }
    //         // addReceive("find posCmdEnd = " + std::to_string(posCmdStart));
    //         posCmdEnd = tmp.find(gsm0710::proto::BASIC_FLAG, posCmdStart + 1);
    //         if(posCmdEnd == -1) {
    //             //start
    //             // std::string final = "";
    //             // for(int i = posCmdStart; i < tmp.size(); i++) {
    //             //     char b[5] = {0};
    //             //     snprintf(b, sizeof(b), "0x%x ", tmp.at(i));
    //             //     final = final + b;
    //             // }
    //             // addReceive("NOT FOUND END " + final);
    //             addReceive("NOT FOUND END ", show);
    //             //end
    //             break;
    //         }
    //         posStart = posCmdEnd + 1;
    //         addReceive("parse = " + std::to_string(posCmdStart) + " - " + std::to_string(posCmdEnd) + " size = " + std::to_string(tmp.size()), showParse);

    //         std::string cmd = tmp.substr(posCmdStart, posCmdEnd - posCmdStart + 1);
            
    //         //start
    //         std::string final = "";
    //         for(size_t i = 0; i < cmd.size(); i++) {
    //             char b[5] = {0};
    //             snprintf(b, sizeof(b), "%x ", cmd.at(i));
    //             final = final + b;
    //         }
    //         // addReceive(final, show);
    //         //end
    //         // continue;
    //         cmd.erase(0, 1);
    //         // address
    //         char address = cmd.at(0);
    //         if (!(address & gsm0710::proto::EA)) {
    //             addReceive("address ok = false", show);
    //             continue;
    //         }
    //         cmd.erase(0, 1);

    //         //control
    //         char control = cmd.at(0);
    //         cmd.erase(0, 1);

    //         // length
    //         int length = cmd.at(0) >> 1;
    //         int hlen = 4;
    //         bool anotherLen = false;
    //         if (!(cmd.at(0) & gsm0710::proto::EA)) {
    //             anotherLen = true;
    //             hlen = 5;
    //             length |= ((size_t)cmd.at(1)) << 7;
    //             addReceive("anotherLen = true length = " + std::to_string(length));
    //             continue;
    //         }
    //         int curLen = length + hlen;
    //         bool sizeOk = true;
    //         if (curLen > bufSize) {
    //             sizeOk = false;
    //             addReceive("sizeOk = false");
    //             continue;
    //         }
    //         cmd.erase(0, hlen == 4? 1: 2); // skip length byte

    //         if(length == 0) {
    //             addReceive("CMUX length = 0\r\n");
    //             continue;
    //         }
    //         cmd.erase(length, cmd.size() - length);
    //         if(show) {
    //             std::string final = "";
    //             for(size_t i = 0; i < cmd.size(); i++) {
    //                 char b[5] = {0};
    //                 snprintf(b, sizeof(b), "%x ", cmd.at(i));
    //                 final = final + b;
    //             }
    //             addReceive(final, show);
             
    //             // addReceive(cmd, show);
              
    //         }
    //     }
        
    //     return false;
    // }

    // bool readCMUX(bool show=false, bool showParse = false) {
    //     int waitI = 0;
    //     while(!_serial.readable()) {
    //         // if(waitI++ >= 100)
    //         //     return false;
    //         ThisThread::sleep_for(10);
    //     }

    //     std::string tmp = "";
    //     while(_serial.readable()) {
    //         char symbol[2] = {0};
    //         _serial.read(symbol, 1);
    //         tmp.push_back(symbol[0]);
    //         // ThisThread::sleep_for(100);
    //     }

    //     int bufSize = tmp.size();

    //     int posCmdStart, posCmdEnd;
    //     int posStart = 0;

    //     // addReceive("next CMUX", show);
    //     // char buf[] = {0xf9, 0x1, 0xef, 0x9, 0xe3, 0x5, 0x7, 0xd, 0x9a, 0xf9, 0xf9, 0x1, 0xef, 0x9, 0xe3, 0x5, 0x7, 0xd, 0x9a, 0xf9};
    //     // tmp = buf;
    //     while(true) {
    //         // addReceive("find posCmdStart = " + std::to_string(posStart));
    //         posCmdStart = tmp.find(proto::BASIC_FLAG, posStart);
    //         if(posCmdStart == -1) {
    //             // addReceive("NOT FOUND START ");
    //             break;
    //         }
    //         tmp.erase(0, posCmdStart);
    //         // address
    //         tmp.erase(0, 1);
    //         char address = tmp.at(0);
    //         if (!(address & proto::EA)) {
    //             addReceive("address ok = false", show);
    //             break;
    //         }

    //         // addReceive("address ok = true", show);

    //         tmp.erase(0, 1);

    //         //control
    //         char control = tmp.at(0);
    //         tmp.erase(0, 1);

    //         // length
    //         int length = tmp.at(0) >> 1;
    //         int hlen = 4;
    //         bool anotherLen = false;
    //         if (!(tmp.at(0) & proto::EA)) {
    //             anotherLen = true;
    //             hlen = 5;
    //             length |= ((size_t)tmp.at(1)) << 7;
    //             addReceive("anotherLen = true length = " + std::to_string(length));
    //             // continue;
    //         }
    //         int curLen = length + hlen;
    //         bool sizeOk = true;
    //         if (curLen > bufSize) {
    //             sizeOk = false;
    //             addReceive("sizeOk = false");
    //             break;
    //         }

    //         tmp.erase(0, hlen == 4? 1: 2); // skip length byte

    //         if(length == 0) {
    //             addReceive("CMUX length = 0\r\n");
    //             break;
    //         }
    //         std::string cmd = tmp.substr(0, length);
    //         tmp.erase(0, length); 
            
    //         posCmdEnd = tmp.find(proto::BASIC_FLAG, 0);
    //         if(posCmdEnd == -1) {
    //             addReceive("posCmdEnd fail");
    //             break;
    //         }


    //         tmp.erase(0, posCmdEnd+1);

    //         if(show) {
    //             std::string final = "";
    //             for(int i = 0; i < cmd.size(); i++) {
    //                 char b[5] = {0};
    //                 snprintf(b, sizeof(b), "%x ", cmd.at(i));
    //                 final = final + b;
    //             }
    //             addReceive(final, show);              
    //         }
    //         break;
    //     }
        
    //     return false;
    // }

    // void readSerialCMUX() {
    //     while(!_serial.readable())
    //         ThisThread::sleep_for(10);
    //     // char test[1000] = {0};
    //     int i = 0;
    //     string tmp;
    //     while(_serial.readable()) {
    //         char symbol[2] = {0};
    //         char test[100] = {0};
    //         _serial.read(symbol, 1);
    //         snprintf(test, sizeof(test), "GET %d BYTE = %x\r\n", i, symbol[0]);
    //         tmp = tmp + test;
    //         // test[i] = symbol[0];
    //         // message.push_back(symbol[0]);
    //         i++;
    //         ThisThread::sleep_for(10);
    //     }
    //     // addFunc(tmp);
    //     // printf("received %d bytes result = \r\n%s\r\n", i, test);
    // }

    // void sendChannel(uint8_t channel, uint8_t control, bool cmd, const uint8_t* data, size_t len) {
    //     bool initiator_ = true;
    //     uint8_t header[5];
    //     uint8_t footer[2];
    //     const size_t hlen = len <= 0x7f ? 4 : 5;

    //     header[0] = gsm0710::proto::BASIC_FLAG;
    //     header[1] = (channel << 2) | gsm0710::proto::EA;
    //     if ((initiator_ && cmd) || (!initiator_ && !cmd)) {
    //         header[1] |= gsm0710::proto::CR;
    //     }
    //     header[2] = control;
    //     header[3] = (len & 0x7f) << 1;
    //     if (hlen == 5) {
    //         header[4] = len >> 7;
    //     } else {
    //         header[3] |= gsm0710::proto::EA;
    //     }

    //     footer[0] = gsm0710::fcs(header + 1, hlen - 1);
    //     footer[1] = gsm0710::proto::BASIC_FLAG;

    //     size_t sent = 0;
    //     while (sent < hlen) {
    //         sent += _serial.write((const char*)header + sent, hlen - sent);
    //         while(!_serial.writable())
    //             ThisThread::sleep_for(100);
    //     }
    //     // ThisThread::sleep_for(200);
    //     // readCMUX();

    //     if (len) {
    //         sent = 0;
    //         while (sent < len) {
    //             sent += _serial.write((const char*)data + sent, len - sent);
    //             while(!_serial.writable())
    //                 ThisThread::sleep_for(100);
    //         }
    //     }
    //     // ThisThread::sleep_for(200);
    //     // readCMUX();

    //     sent = 0;
    //     while (sent < sizeof(footer)) {
    //         sent += _serial.write((const char*)footer + sent, sizeof(footer) - sent);
    //         while(!_serial.writable())
    //             ThisThread::sleep_for(100);
    //     }
    //     // ThisThread::sleep_for(200);
    //     // readCMUX();

    //     // auto t1 = portable::getMillis();

    //     // size_t sent = 0;
    //     // while (sent < hlen) {
    //     //     sent += CHECK(stream_->write((const char*)header + sent, hlen - sent));
    //     //     if ((portable::getMillis() - t1) > getControlResponseTimeout() * 2) {
    //     //         GSM0710_LOG_DEBUG(ERROR, "Timeout writing into stream");
    //     //         return GSM0710_ERROR_FLOW_CONTROL;
    //     //     }
    //     //     CHECK(stream_->waitEvent(StreamT::WRITABLE, std::max<int>(0, getControlResponseTimeout() * 2 - (portable::getMillis() - t1))));
    //     // }

    //     // size_t sent = 0;
    //     // while (sent < hlen) {
    //     //     sent += _serial.write((const char*)header + sent, hlen - sent);
    //     //     while(!_serial.writable())
    //     //         ThisThread::sleep_for(10);
    //     // }

    //     // t1 = portable::getMillis();
    //     // if (len) {
    //     //     sent = 0;
    //     //     while (sent < len) {
    //     //         sent += CHECK(stream_->write((const char*)data + sent, len - sent));
    //     //         if ((portable::getMillis() - t1) > getControlResponseTimeout() * 2) {
    //     //             GSM0710_LOG_DEBUG(ERROR, "Timeout writing into stream");
    //     //             return GSM0710_ERROR_FLOW_CONTROL;
    //     //         }
    //     //         CHECK(stream_->waitEvent(StreamT::WRITABLE, std::max<int>(0, getControlResponseTimeout() * 2 - (portable::getMillis() - t1))));
    //     //     }
    //     // }

    //     // sent = 0;
    //     // t1 = portable::getMillis();
    //     // while (sent < sizeof(footer)) {
    //     //     sent += CHECK(stream_->write((const char*)footer + sent, sizeof(footer) - sent));
    //     //     if ((portable::getMillis() - t1) > getControlResponseTimeout() * 2) {
    //     //         GSM0710_LOG_DEBUG(ERROR, "Timeout writing into stream");
    //     //         return GSM0710_ERROR_FLOW_CONTROL;
    //     //     }
    //     //     CHECK(stream_->waitEvent(StreamT::WRITABLE, std::max<int>(0, getControlResponseTimeout() * 2 - (portable::getMillis() - t1))));
    //     // }

    // }